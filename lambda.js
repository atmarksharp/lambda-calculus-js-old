

var G;

if(typeof window == 'undefined'){
   G = GLOBAL;
}else{
  G = window;
}

(function(){

  // ===================================
  // -----------------------------------
  //
  //   Parser (generated by kmyacc)
  //
  // -----------------------------------
  // ===================================


/* Prototype file of JavaScript parser.
 * Written by MORI Koichiro
 * This file is PUBLIC DOMAIN.
 */

var buffer;
var token;
var toktype;

var YYERRTOK = 256;
var ID = 257;
var IDENTIFIER = 258;
var LID = 259;
var PARAMETERS = 260;

  
/*
  #define yyclearin (yychar = -1)
  #define yyerrok (yyerrflag = 0)
  #define YYRECOVERING (yyerrflag != 0)
  #define YYERROR  goto yyerrlab
*/


/** Debug mode flag **/
var yydebug = false;

/** lexical element object **/
var yylval = null;

/** Dialog window **/
var yywin = null;
var yydoc = null;

function yydocopen() {
  if (yywin == null) {
    yywin = window.open("", "yaccdiag", "resizable,status,width=600,height=400");
    yydoc = null;
  }
  if (yydoc == null)
    yydoc = yywin.document;
  yydoc.open();
}

function yyprintln(msg)
{
  if (yydoc == null)
    yydocopen();
  yydoc.write(msg + "<br>");
}

function yyflush()
{
  if (yydoc != null) {
    yydoc.close();
    yydoc = null;
    yywin = null;
  }
}



var yytranslate = [
      0,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    2,    8,    8,    6,    8,    8,    8,    8,
      4,    5,    8,    8,    8,    8,    7,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    8,    8,    8,    8,
      8,    8,    8,    8,    8,    8,    1,    3,    8,    8,
      8
  ];

var YYBADCH = 8;
var YYMAXLEX = 261;
var YYTERMS = 8;
var YYNONTERMS = 5;

var yyaction = [
     17,    1,    0,    5,    6,    2,    3,    0,    0,   14
  ];

var YYLAST = 10;

var yycheck = [
      3,    4,    0,    6,    3,    2,    7,   -1,   -1,    5
  ];

var yybase = [
     -3,   -3,   -3,   -3,    4,    1,    1,    2,    3,   -1,
      3,    0,    0,    0,    0,    3
  ];

var YY2TBLSTATE = 5;

var yydefault = [
  32767,32767,32767,32767,32767,32767,    8,32767,    2,32767,
      4
  ];



var yygoto = [
      4,   16,   10,   18
  ];

var YYGLAST = 4;

var yygcheck = [
      3,    3,    3,    4
  ];

var yygbase = [
      0,    0,    0,   -1,   -3
  ];

var yygdefault = [
  -32768,    7,   12,    8,    9
  ];

var yylhs = [
      0,    1,    2,    3,    3,    3,    3,    4,    4
  ];

var yylen = [
      1,    1,    1,    3,    4,    3,    1,    2,    1
  ];

var YYSTATES = 16;
var YYNLSTATES = 11;
var YYINTERRTOK = 1;
var YYUNEXPECTED = 32767;
var YYDEFAULT = -32766;

/*
 * Parser entry point
 */

function yyparse()
{
  var yyastk = new Array();
  var yysstk = new Array();

  yystate = 0;
  yychar = -1;

  yysp = 0;
  yysstk[yysp] = 0;
  yyerrflag = 0;
  for (;;) {
    if (yybase[yystate] == 0)
      yyn = yydefault[yystate];
    else {
      if (yychar < 0) {
        if ((yychar = yylex()) <= 0) yychar = 0;
        yychar = yychar < YYMAXLEX ? yytranslate[yychar] : YYBADCH;
      }

      if (((yyn = yybase[yystate] + yychar) >= 0
	    && yyn < YYLAST && yycheck[yyn] == yychar
           || (yystate < YY2TBLSTATE
               && (yyn = yybase[yystate + YYNLSTATES] + yychar) >= 0
               && yyn < YYLAST && yycheck[yyn] == yychar))
	  && (yyn = yyaction[yyn]) != YYDEFAULT) {
        /*
         * >= YYNLSTATE: shift and reduce
         * > 0: shift
         * = 0: accept
         * < 0: reduce
         * = -YYUNEXPECTED: error
         */
        if (yyn > 0) {
          /* shift */
          yysp++;

          yysstk[yysp] = yystate = yyn;
          yyastk[yysp] = yylval;
          yychar = -1;
          
          if (yyerrflag > 0)
            yyerrflag--;
          if (yyn < YYNLSTATES)
            continue;
            
          /* yyn >= YYNLSTATES means shift-and-reduce */
          yyn -= YYNLSTATES;
        } else
          yyn = -yyn;
      } else
        yyn = yydefault[yystate];
    }
      
    for (;;) {
      /* reduce/error */
      if (yyn == 0) {
        /* accept */
        yyflush();
        return 0;
      }
      else if (yyn != YYUNEXPECTED) {
        /* reduce */
        yyl = yylen[yyn];
        yyval = yyastk[yysp-yyl+1];
        /* Following line will be replaced by reduce actions */
        switch(yyn) {
        case 2:
{ returnValue = yyastk[yysp-(1-1)]; /* expr */ } break;
        case 3:
{ yyval = yyastk[yysp-(3-2)]; /* '(' expr ')' */ } break;
        case 4:
{ yyval = lambdaGenerator(yyastk[yysp-(4-2)],yyastk[yysp-(4-4)]); /* '#' parameters '.' expr */ } break;
        case 5:
{ yyval = new App(yyastk[yysp-(3-1)],yyastk[yysp-(3-3)]); /* expr ' ' expr */ } break;
        case 6:
{ yyval = new Var(yyastk[yysp-(1-1)]); /* ID */ } break;
        case 7:
{ yyval = (yyastk[yysp-(2-1)] + yyastk[yysp-(2-2)]); /* ID parameter */ } break;
        case 8:
{ yyval = yyastk[yysp-(1-1)]; /* ID */ } break;
        }
        /* Goto - shift nonterminal */
        yysp -= yyl;
        yyn = yylhs[yyn];
        if ((yyp = yygbase[yyn] + yysstk[yysp]) >= 0 && yyp < YYGLAST
            && yygcheck[yyp] == yyn)
          yystate = yygoto[yyp];
        else
          yystate = yygdefault[yyn];
          
        yysp++;

        yysstk[yysp] = yystate;
        yyastk[yysp] = yyval;
      }
      else {
        /* error */
        switch (yyerrflag) {
        case 0:
          yyerror("syntax error");
        case 1:
        case 2:
          yyerrflag = 3;
          /* Pop until error-expecting state uncovered */

          while (!((yyn = yybase[yystate] + YYINTERRTOK) >= 0
                   && yyn < YYLAST && yycheck[yyn] == YYINTERRTOK
                   || (yystate < YY2TBLSTATE
                       && (yyn = yybase[yystate + YYNLSTATES] + YYINTERRTOK) >= 0
                       && yyn < YYLAST && yycheck[yyn] == YYINTERRTOK))) {
            if (yysp <= 0) {
              yyflush();
              return 1;
            }
            yystate = yysstk[--yysp];
          }
          yyn = yyaction[yyn];
          yysstk[++yysp] = yystate = yyn;
          break;

        case 3:
          if (yychar == 0) {
            yyflush();
            return 1;
          }
          yychar = -1;
          break;
        }
      }
        
      if (yystate < YYNLSTATES)
        break;
      /* >= YYNLSTATES means shift-and-reduce */
      yyn = yystate - YYNLSTATES;
    }
  }
}



  // ===================================
  // -----------------------------------
  //
  //    Simplifier
  //
  // -----------------------------------
  // ===================================


  // Utility Functions ===========

  function _map(arr, func){
    var ret = [];
    for (var i=0; i<arr.length; i++) {
      ret.push(func(arr[i],i));
    };
    return ret;
  }

  // Classes reperesents lambda expressions =============

  // Variant (ex: a,b,c ...)
  function Var(name){ 
    this.name = name; // String
    this.simplify = function(){
      return G.lambdaSimplify(this);
    }
    this.str = function(){
      return lambdaStringify(this);
    }
    this.real_str = function(){
      return this.name;
    }
    this.removeGensym = function(){
      if(this.name[0] == '%'){
        this.name = gensymMap[this.name];
      }
      return this;
    }
  }

  // Syntax sugar of Var
  function v(name){
    return new Var(name);
  }

  // Lambda function (ex: \x.x, \x.(\y.x) ...)
  function Abs(arg, expr){ 
    this.arg = arg; // String
    this.expr = expr;
    this.str = function(){
      return lambdaStringify(this);
    }
    this.real_str = function(){
      return '(λ'+this.arg+'.'+this.expr.real_str()+')';
    }
    this.simplify = function(){
      return G.lambdaSimplify(this);
    }
    this.removeGensym = function(){
      if(this.arg[0] == '%'){
        this.arg = gensymMap[this.arg];
      }
      this.expr = this.expr.removeGensym();
      return this;
    }
  }

  // Syntax sugar of Abs
  function F(arg, expr){
    return new Abs(arg, expr);
  }

  // Applying (ex: e1 e2)
  function App(expr1, expr2){
    this.expr1 = expr1;
    this.expr2 = expr2;
    this.simplify = function(){
      return G.lambdaSimplify(this);
    }
    this.str = function(){
      return lambdaStringify(this);
    }
    this.real_str = function(){
      return '('+this.expr1.real_str()+' '+this.expr2.real_str()+')';
    }
    this.removeGensym = function(){
      this.expr1 = this.expr1.removeGensym();
      this.expr2 = this.expr2.removeGensym();
      return this;
    }
  }

  // Syntax sugar of App
  function app(expr1, expr2){
    return new App(expr1, expr2);
  }

  // Simplifying Functions ===========================


  // a function that creates new name of a variable
  var gensym_counter = 0;
  var gensymMap = {};
  function gensym(old){
    gensym_counter++; // inclements static gensym_counter
    if(old[0] == '%'){
      gensymMap['%'+gensym_counter] = gensymMap[old];
    }else{
      gensymMap['%'+gensym_counter] = old;
    }
    return '%'+gensym_counter; // returns g1, g2, g3, ... when gensym was called.
  }

  // Solve "[e2/x]e1" and returns it
  function subst(e2, x, e1){

    // console.log('subst: [e2/x]e1 = [ '+e2.str()+' / '+x+' ] '+e1.str());

    if(e1 instanceof Var){
      var y = e1.name;
      return (x == y)? e2: new Var(y)
    }else if(e1 instanceof Abs){
      var y = e1.arg;
      var e = e1.expr;
      var y_ = gensym(y);
      var ne0 = subst(new Var(y_), y, e);
      var ne2 = subst(e2, x, ne0);
      return new Abs(y_, ne2);
    }else if(e1 instanceof App){
      var e = e1.expr1;
      var e_ = e1.expr2;
      var ne1 = subst(e2, x, e);
      var ne2 = subst(e2, x, e_);
      return new App(ne1, ne2);
    }
  }

  // A step of simplifying. This receives 'e', and returns a list of e' (e-dash) at e -> e'.
  function step(e){

    // console.log('step: e = ' + e.str());

    if(e instanceof Var){
      return [];
    }else if(e instanceof Abs){
      var x = e.arg; 
      var e0 = e.expr;

      // (R-Abs) 
      var ret = _map(step(e0),function(e0_){
        return new Abs(x,e0_)
      });

      return ret;
    }else if(e instanceof App){
      var e1 = e.expr1;
      var e2 = e.expr2;

      // (R-Beta) 
      var list1;
      if(e1 instanceof Abs){
        var x = e1.arg;
        var e0 = e1.expr;
        var ne0 = subst(e2, x, e0);
        list1 = [ne0];
      }else{
        list1 = [];
      }

      // (R-App1) 
      var list2 = _map(step(e1),function(e1_){
        return new App(e1_,e2)
      });

      // (R-App2) 
      var list3 = _map(step(e2),function(e2_){
        return new App(e1,e2_)
      });

      return list1.concat(list2).concat(list3);
    }
  }

  // Repeat steps until expr is completely simplified
  function repeat(e){
    // console.log('repeat: e = ' + e.str());

    var list = step(e);
    if(list.length == 0){
      return e.removeGensym();
    }else{
      return repeat(list[0]);
    }
  }

  G.Var = Var;
  G.v = v;
  G.Abs = Abs;
  G.F = F;
  G.App = App;
  G.app = app;

  G.gensymMap = gensymMap;

  G.lambdaSimplify = repeat;


  // ===================================
  // -----------------------------------
  //
  //    User Defined Parser Functions
  //
  // -----------------------------------
  // ===================================


  // Get difinition value (ex: id=TRUE(#xy.x))
  function getDefine(id){
    var expr = __defines[id];
    if(expr == null){
      throw new Error("'" + id + "' is not defined")
    }else{
      return expr;
    }
  }

  // Generate lambdas with parameters (#xyz.body)
  function lambdaGenerator(parameterStr, body){
    var parameters = parameterStr.split('').reverse();
    var implement = body;
    var lambda = null;
    for (var i=0; i<parameters.length; i++) {
      var p = parameters[i];
      lambda = new Abs(p, implement);
      implement = lambda;
    };
    return lambda;
  }

  function lambdaStringify(expr){
    var expr_real_str = expr.real_str();

    for (var i=0; i<__defineKeys.length; i++) {
      var key = __defineKeys[i];
      var value = __defines[key];
      if(expr.constructor.name == value.constructor.name && expr_real_str == value.real_str()){
        return key;
      }
    }

    return expr_real_str;
  }

  // Parser's fields and functions ==============================

  var token;
  var buffer;
  var errorMessage;
  var __defines = {};
  var __defineKeys = [];
  var returnValue = null;

  function isID(s){
    return 'abcdefghijklmnopqrstuvwxyz'.indexOf(s) > -1;
  }

  function isLargeID(s){
    return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'.indexOf(s) > -1;
  }

  function yylex() {
    yylval = null;

    while(buffer != '' && (buffer.charAt(0) == '\n' || buffer.charAt(0) == '\t')){
      token = buffer.substr(0, 1);
      buffer = buffer.substr(1);
    }

    var c = buffer.charAt(0);

    if(buffer.length == 0){
      return 0;
    } else if (isID(c)) {
      token = c;
      buffer = buffer.substr(1);
      yylval = token;
      return ID;
    } else if (isLargeID(c)) {
      token = c;
      buffer = buffer.substr(1);
      yylval = token;
      return LID;
    } else {
      token = buffer.substr(0, 1);
      buffer = buffer.substr(1);
      return token.charCodeAt(0);
    }
  }

  function yyerror(msg) {
    throw new Error(msg);
    // yyprintln(msg);
  }


  // parseLambda =============================

  // str: lambda string
  // defs: definition dictionary (ex: {'TRUE':'(λxy.x)'} )

  function parseLambda(str, defs){
    return __parseLambdaImpl(str, defs, null);
  }

  function __parseLambdaImpl(str, _defs, no_reset) {
    var defs = _defs || {};
    var keys = [];

    // Resets defines at new parsing
    if(no_reset == null){
      __defineKeys = [];
      __defines = {};
    }

    // Parse lambdas of defines
    if(_defs != null){
      for(var k in defs){ keys.push(k) };
      for (var i=0; i<keys.length; i++) {
        var key = keys[i];
        __defines[key] = __parseLambdaImpl(defs[key], null, 'no-reset');
      };

      __defineKeys = keys;
    }

    for (var i=0; i<__defineKeys.length; i++) {
      var key = __defineKeys[i];
      str = str.split(key).join(defs[key]);
    };

    // Parse
    buffer = str.split('λ').join('#');
    yyparse();

    // Returns expr
    return returnValue;
  }

  G.parseLambda = parseLambda;
  G.L = parseLambda;
  G.lambda = parseLambda;

})();
