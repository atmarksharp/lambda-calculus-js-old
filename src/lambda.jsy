%{

var G;

if(typeof window == 'undefined'){
   G = GLOBAL;
}else{
  G = window;
}

(function(){

  // ===================================
  // -----------------------------------
  //
  //   Parser (generated by kmyacc)
  //
  // -----------------------------------
  // ===================================

%}

%left ' '
%token ID IDENTIFIER
%token LID IDENTIFIER
%token PARAMETERS IDENTIFIER

%%

start: line;

line
  : expr { returnValue = $1; /* expr */ }
  ;

expr
  : '(' expr ')' { $$ = $2; /* '(' expr ')' */ }
  | '#' parameters '.' expr { $$ = lambdaGenerator($2,$4); /* '#' parameters '.' expr */ }
  | expr ' ' expr { $$ = new App($1,$3); /* expr ' ' expr */ }
  | ID { $$ = new Var($1); /* ID */ }
  ;

parameters
  : ID parameters { $$ = ($1 + $2); /* ID parameter */ }
  | ID { $$ = $1; /* ID */ }
  ;

%%

  // ===================================
  // -----------------------------------
  //
  //    Simplifier
  //
  // -----------------------------------
  // ===================================


  // Utility Functions ===========

  function _map(arr, func){
    var ret = [];
    for (var i=0; i<arr.length; i++) {
      ret.push(func(arr[i],i));
    };
    return ret;
  }

  // Classes reperesents lambda expressions =============

  // Variant (ex: a,b,c ...)
  function Var(name){ 
    this.name = name; // String
    this.simplify = function(){
      return G.lambdaSimplify(this);
    }
    this.str = function(){
      return lambdaStringify(this);
    }
    this.real_str = function(){
      return this.name;
    }
    this.removeGensym = function(){
      if(this.name[0] == '%'){
        this.name = gensymMap[this.name];
      }
      return this;
    }
  }

  // Syntax sugar of Var
  function v(name){
    return new Var(name);
  }

  // Lambda function (ex: \x.x, \x.(\y.x) ...)
  function Abs(arg, expr){ 
    this.arg = arg; // String
    this.expr = expr;
    this.str = function(){
      return lambdaStringify(this);
    }
    this.real_str = function(){
      return '(λ'+this.arg+'.'+this.expr.real_str()+')';
    }
    this.simplify = function(){
      return G.lambdaSimplify(this);
    }
    this.removeGensym = function(){
      if(this.arg[0] == '%'){
        this.arg = gensymMap[this.arg];
      }
      this.expr = this.expr.removeGensym();
      return this;
    }
  }

  // Syntax sugar of Abs
  function F(arg, expr){
    return new Abs(arg, expr);
  }

  // Applying (ex: e1 e2)
  function App(expr1, expr2){
    this.expr1 = expr1;
    this.expr2 = expr2;
    this.simplify = function(){
      return G.lambdaSimplify(this);
    }
    this.str = function(){
      return lambdaStringify(this);
    }
    this.real_str = function(){
      return '('+this.expr1.real_str()+' '+this.expr2.real_str()+')';
    }
    this.removeGensym = function(){
      this.expr1 = this.expr1.removeGensym();
      this.expr2 = this.expr2.removeGensym();
      return this;
    }
  }

  // Syntax sugar of App
  function app(expr1, expr2){
    return new App(expr1, expr2);
  }

  // Simplifying Functions ===========================


  // a function that creates new name of a variable
  var gensym_counter = 0;
  var gensymMap = {};
  function gensym(old){
    gensym_counter++; // inclements static gensym_counter
    if(old[0] == '%'){
      gensymMap['%'+gensym_counter] = gensymMap[old];
    }else{
      gensymMap['%'+gensym_counter] = old;
    }
    return '%'+gensym_counter; // returns g1, g2, g3, ... when gensym was called.
  }

  // Solve "[e2/x]e1" and returns it
  function subst(e2, x, e1){

    // console.log('subst: [e2/x]e1 = [ '+e2.str()+' / '+x+' ] '+e1.str());

    if(e1 instanceof Var){
      var y = e1.name;
      return (x == y)? e2: new Var(y)
    }else if(e1 instanceof Abs){
      var y = e1.arg;
      var e = e1.expr;
      var y_ = gensym(y);
      var ne0 = subst(new Var(y_), y, e);
      var ne2 = subst(e2, x, ne0);
      return new Abs(y_, ne2);
    }else if(e1 instanceof App){
      var e = e1.expr1;
      var e_ = e1.expr2;
      var ne1 = subst(e2, x, e);
      var ne2 = subst(e2, x, e_);
      return new App(ne1, ne2);
    }
  }

  // A step of simplifying. This receives 'e', and returns a list of e' (e-dash) at e -> e'.
  function step(e){

    // console.log('step: e = ' + e.str());

    if(e instanceof Var){
      return [];
    }else if(e instanceof Abs){
      var x = e.arg; 
      var e0 = e.expr;

      // (R-Abs) 
      var ret = _map(step(e0),function(e0_){
        return new Abs(x,e0_)
      });

      return ret;
    }else if(e instanceof App){
      var e1 = e.expr1;
      var e2 = e.expr2;

      // (R-Beta) 
      var list1;
      if(e1 instanceof Abs){
        var x = e1.arg;
        var e0 = e1.expr;
        var ne0 = subst(e2, x, e0);
        list1 = [ne0];
      }else{
        list1 = [];
      }

      // (R-App1) 
      var list2 = _map(step(e1),function(e1_){
        return new App(e1_,e2)
      });

      // (R-App2) 
      var list3 = _map(step(e2),function(e2_){
        return new App(e1,e2_)
      });

      return list1.concat(list2).concat(list3);
    }
  }

  // Repeat steps until expr is completely simplified
  function repeat(e){
    // console.log('repeat: e = ' + e.str());

    var list = step(e);
    if(list.length == 0){
      return e.removeGensym();
    }else{
      return repeat(list[0]);
    }
  }

  G.Var = Var;
  G.v = v;
  G.Abs = Abs;
  G.F = F;
  G.App = App;
  G.app = app;

  G.gensymMap = gensymMap;

  G.lambdaSimplify = repeat;


  // ===================================
  // -----------------------------------
  //
  //    User Defined Parser Functions
  //
  // -----------------------------------
  // ===================================


  // Get difinition value (ex: id=TRUE(#xy.x))
  function getDefine(id){
    var expr = __defines[id];
    if(expr == null){
      throw new Error("'" + id + "' is not defined")
    }else{
      return expr;
    }
  }

  // Generate lambdas with parameters (#xyz.body)
  function lambdaGenerator(parameterStr, body){
    var parameters = parameterStr.split('').reverse();
    var implement = body;
    var lambda = null;
    for (var i=0; i<parameters.length; i++) {
      var p = parameters[i];
      lambda = new Abs(p, implement);
      implement = lambda;
    };
    return lambda;
  }

  function lambdaStringify(expr){
    var expr_real_str = expr.real_str();

    for (var i=0; i<__defineKeys.length; i++) {
      var key = __defineKeys[i];
      var value = __defines[key];
      if(expr.constructor.name == value.constructor.name && expr_real_str == value.real_str()){
        return key;
      }
    }

    return expr_real_str;
  }

  // Parser's fields and functions ==============================

  var token;
  var buffer;
  var errorMessage;
  var __defines = {};
  var __defineKeys = [];
  var returnValue = null;

  function isID(s){
    return 'abcdefghijklmnopqrstuvwxyz'.indexOf(s) > -1;
  }

  function isLargeID(s){
    return 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_0123456789'.indexOf(s) > -1;
  }

  function yylex() {
    yylval = null;

    while(buffer != '' && (buffer.charAt(0) == '\n' || buffer.charAt(0) == '\t')){
      token = buffer.substr(0, 1);
      buffer = buffer.substr(1);
    }

    var c = buffer.charAt(0);

    if(buffer.length == 0){
      return 0;
    } else if (isID(c)) {
      token = c;
      buffer = buffer.substr(1);
      yylval = token;
      return ID;
    } else if (isLargeID(c)) {
      token = c;
      buffer = buffer.substr(1);
      yylval = token;
      return LID;
    } else {
      token = buffer.substr(0, 1);
      buffer = buffer.substr(1);
      return token.charCodeAt(0);
    }
  }

  function yyerror(msg) {
    throw new Error(msg);
    // yyprintln(msg);
  }


  // parseLambda =============================

  // str: lambda string
  // defs: definition dictionary (ex: {'TRUE':'(λxy.x)'} )

  function parseLambda(str, defs){
    return __parseLambdaImpl(str, defs, null);
  }

  function __parseLambdaImpl(str, _defs, no_reset) {
    var defs = _defs || {};
    var keys = [];

    // Resets defines at new parsing
    if(no_reset == null){
      __defineKeys = [];
      __defines = {};
    }

    // Parse lambdas of defines
    if(_defs != null){
      for(var k in defs){ keys.push(k) };
      for (var i=0; i<keys.length; i++) {
        var key = keys[i];
        __defines[key] = __parseLambdaImpl(defs[key], null, 'no-reset');
      };

      __defineKeys = keys;
    }

    for (var i=0; i<__defineKeys.length; i++) {
      var key = __defineKeys[i];
      str = str.split(key).join(defs[key]);
    };

    // Parse
    buffer = str.split('λ').join('#');
    yyparse();

    // Returns expr
    return returnValue;
  }

  G.parseLambda = parseLambda;
  G.L = parseLambda;
  G.lambda = parseLambda;

})();
